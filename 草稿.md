# 前提条件

但**前提是你能把“路由到同一台机器”升级为“同一时刻只有一个节点拥有该 signer 的执行权”**。仅靠网关路由或一致性 hash 还不够，故障/网络分区/扩缩容时会出现短暂双活，仍会竞态。

### 你的观点哪里成立

- **稳态**（节点健康、路由稳定）：让每个节点只处理自己负责的 signer，确实能把并发问题降到最低，基本等价于 FireFly 的“按 signer 串行化”。

### 最大风险点

- **故障转移窗口**：旧节点“还在跑但路由已切走”、或网络分区导致两边都以为自己负责这个 signer（脑裂）。
- 这会直接破坏 nonce/终局回写：重复分配、重复 resubmit、旧节点迟到回写覆盖新节点。

### 最优解（结合 FireFly 思路 + 你的架构）：路由分片 + 分布式租约 + fencing

把系统拆成两层：

1) **路由层**：尽量把 signer 请求打到“应负责的节点”（性能）
2) **执行权层**：最终以“租约与 fencing”决定谁能对该 signer 做关键写入（正确性）

#### 1) 路由层怎么做

- **一致性哈希/固定分片**：`signer -> shard -> node`
- 网关/SDK 只负责把请求尽量路由到目标节点；路由错了也没关系（下一层会挡住）。

#### 2) 执行权层怎么做（关键）

为每个 signer 建立一个 **lease**（租约）：

- 表：`signer_lease(signer, owner_node, fencing_token, expires_at)`
- 规则：
  - 节点处理 signer 前先“抢占或续租 lease”（CAS 更新 `expires_at`，并在抢占时 `fencing_token++`）。
  - **所有关键写操作必须带 fencing_token 校验**（写入 nonce、写入 txHash、状态推进、resubmit 调度、终局回写等）。旧 token 的写一律拒绝。
- 这相当于把 FireFly 的“单进程串行”升级为“分布式单主串行”。

#### 3) 把 FireFly/你们的关键逻辑放到“leader-only”

- **nonce 分配**：只有持 lease 的节点能分配；并且分配落库要校验 fencing_token。
- **resubmit（同 nonce 重提）**：只有 leader 执行；调度也要落库防重复（如 `next_resubmit_at`）。
- **终局确认回写**：receipt/confirmations 的“计算”可以多节点并行，但“写回 USED/回退/覆盖 confirmations”必须 leader-only 且 fencing 校验，避免重组时写乱。

### 为什么这是最优

- **性能**：稳态时几乎全走本地分片，无全局锁争用。
- **正确性**：故障转移时即使短暂双活，旧节点因为 fencing 失效无法写入，竞态被硬切断。
- **对齐 FireFly 的核心原则**：同 signer 的序列化是根本；你只是把序列化边界从进程内扩展到集群。

# FireFly Transaction Manager 方案研究报告

> 目标：提炼 FireFly Transaction Manager（FFTM）在 **nonce 分配** 与 **链上状态跟踪到终局** 方面的可复用方法论，覆盖“nonce 正常消费/未正常消费”的主要场景与对应处理策略，供其他项目落地参考。
>
> 说明：本报告聚焦 **与 nonce、交易提交、receipt、确认数、重组、重提、幂等与持久化一致性** 直接相关的代码路径；FFTM 内与此无关的模块（如 eventstream webhook/websocket 分发细节、指标/HTTP server 等）不作为展开重点。

---

## 1. FFTM 的总体架构取向

### 1.1 “源头管理 at source”

- FFTM 的核心假设：**同一签名密钥的交易应由同一个 nonce 管理系统统一治理**。
- 代价与边界：
  - 如果密钥被多系统共享，FFTM 仍可运行，但会依赖更保守的策略（例如把 `transactions.nonceStateTimeout` 调到接近 0），牺牲性能换正确性窗口缩小。

### 1.2 交易即 nonce 索引（关键差异点）

- FFTM 并未像本项目那样用独立的 `allocation(status=RESERVED/USED/RECYCLABLE)` 表描述 nonce 生命周期。
- 它把 **“交易记录（ManagedTX）”** 当作 nonce 的事实载体：nonce 一旦分配，就写入交易记录并进入统一的交易状态机（Pending/Tracking/Confirmed 等）。
- 好处：nonce 与交易状态天然绑定，便于“重提同 nonce”“对账”“确认数推进”“重组回滚时重算确认列表”等闭环。

---

## 2. Nonce 分配：并发控制与“链上 vs 本地”决策

### 2.1 Postgres：确定性路由 worker 串行化（强建议借鉴）

- 核心：把 **同一 signer 的插入/nonce 分配请求** 路由到同一个 writer worker，从源头避免并发冲突。
- `internal/persistence/postgres/transaction_writer.go`：
  - `queue()`：插入按 `From(signer)` 路由；更新按 `txID` 路由。
  - `worker()`：批处理（batchSize/batchTimeout），提升吞吐。
  - `runBatch()`：在一个 DB group/事务中执行 nonce 分配、插入、更新、receipt upsert、confirmations 写入、history 写入、completions 写入与删除。

### 2.2 Postgres：三级决策 max(chain, cache, db)

- `assignNonces()` 关键规则：
  - 若缓存有效：直接用 `cacheEntry.nextNonce` 递增分配。
  - 若缓存缺失/过期：调用 `NextNonceForSigner` 得到链上 next nonce；再取内部 next nonce（来自过期缓存或 DB 中最高 nonce+1）；取两者最大值。
  - 分配后 `nextNonce++` 写回 LRU 缓存。
- 关键设计点：
  - “过期缓存仍用于比较”：防止同一批次未提交时 DB 落后于缓存导致回退。
  - 批次失败清理缓存 `clearCachedNonces()`：防止“缓存递增了但 DB 没提交成功”导致跳号。

### 2.3 幂等：避免“重复请求”消耗 nonce

- `pkg/txhandler/simple/simple_transaction_handler.go`：
  - `requestIDPreCheck()`：对外部请求 ID 做 DB 预查，尽量早返回 409，避免进入后续链上查询与资源消耗。
- `internal/persistence/postgres/transaction_writer.go`：
  - `preInsertIdempotencyCheck()`：批处理插入前做二次检查（针对并发 API 调用的小窗口），发现重复则 `sentConflict=true`，该 op 不参与 nonce 分配。

---

## 3. 交易提交与“nonce 是否真正被消费”

### 3.1 提交前拒绝：nonce 不会被“花掉”

- `pkg/ffcapi/submission_error.go`：
  - `MapSubmissionRejected()`：把 **输入非法、revert、余额不足** 等定义为 `SubmissionRejected=true`。
  - 语义：交易在 prepare 阶段已被判定必失败，因此 **不会进入 FFTM 持久化**，也就不会占用 nonce。
- `simple_transaction_handler.go`：
  - `TransactionPrepare`/`DeployContractPrepare` 失败直接返回；只在 prepare 成功后才创建 ManagedTX 并进入 nonce 分配持久化。

### 3.2 提交成功与“已知交易”错误：把“链上/节点已接收”与“本地成功”解耦

> ##### 适用场景
>
> - 网络超时/重试导致同一笔交易被再次 send
>
> - resubmit 机制按固定间隔用同一 nonce 重发
>
> - 应用重启恢复后对同一笔已提交交易再次尝试提交
>
> ##### 这段逻辑的作用
>
> - 让提交操作幂等：重复发送不会把交易误判为失败。
>
> ##### 它防止什么问题
>
> - 防止因为“重复提交返回错误”而触发 错误的失败处理（例如把交易标记失败、错误回收/重新分配 nonce、或引发不必要的告警与重试风暴）。

- `submitTX()` 的关键分支：
  - 成功：写入 `tx_hash`、`last_submit`，子状态进入 Tracking。
  - 失败但 reason 为 `ErrorKnownTransaction` 或 `ErrorReasonNonceTooLow`：
    - 如果本地已有 `TransactionHash`：认为是可接受的幂等/重复提交现象，返回成功。
    - 如果本地没有 `TransactionHash`：返回错误，并明确指出需要 connector 支持“重算预期 tx hash”的能力来补齐这个灰区。

### 3.3 长期 pending：定期 resubmit 同 nonce（强建议借鉴）

- `processTransaction()`：
  - 若无 receipt 且超过 `resubmitInterval`：记录 Timeout 动作，切到 Stale 子状态，再次 `submitTX()`。
  - 目的：处理“交易池驱逐、节点重启丢失 mempool、网络抖动”等导致 txHash 长期无 receipt 的情况。
- 注意：simple handler 没有 gas bump 策略；代码也明确提示更高级策略可以逐步提高 gas。(这一部分要给业务开放一个方法，让业务根据返回的情况自行决定怎么处理以及处理细节，这边只开发钩子预留处理的可选项)

---

## 4. 终局确认：receipt 异步拉取 + 确认数 + 重组检测

### 4.1 receiptChecker：异步、无界队列、错误不阻塞主路径

> 这段逻辑的意思是：receipt 查询被做成异步后台队列，任何单笔交易的“查不到 receipt”或“节点临时报错”，都不会卡住系统主流程。
>
> ##### 适用场景
>
> - 你需要持续跟踪很多笔已广播交易的终局状态，但 receipt 可能长时间不存在（pending）。
>
> - 节点/RPC 会出现 短暂故障、限流、抖动，对某些 txHash 返回错误或超时。
>
> - 需要保证“终局跟踪”不会反向拖垮“交易接入/事件处理”等关键路径。
>
> ##### 这段逻辑的作用
>
> - NotFound：说明交易还没上链或节点还查不到 receipt → 仅更新时间戳，稍后再查。
>
> - 非 NotFound 错误：说明节点查询出错（可能是临时问题）→ 把该 tx 放到队尾并走退避重试，避免一直盯着它紧密重试。
>
> ##### 它在防止什么问题
>
> - 防止 关键路径被 receipt 查询阻塞（队列满、线程被占满）。
>
> - 防止 单个异常 tx 或节点错误导致整个 receipt 检查队列“卡死在队头”，其它交易永远查不到。
>
> - 防止 错误情况下的紧密自旋（高频查询把节点打挂、把自己打满）。

- `internal/confirmations/receipt_checker.go`：
  - 用 `list.List` 存储待检查条目，避免固定长度队列导致“关键路径阻塞”。
  - worker 取队头检查 receipt：
    - NotFound：视为未就绪，更新 `lastReceiptCheck`，不报错。
    - 非 NotFound 错误：把条目放回队尾并触发 retry backoff，避免单条卡死。

### 4.2 blockConfirmationManager：把“链视图一致性”放在首位

> 这段逻辑的意思是：用一个“确认管理器”把 pending 的交易或事件先挂起来，异步拿到 receipt 后再沿链回溯计算确认数，并且在一次处理循环里对链保持“同一视图”。
>
> ##### 适用场景
>
> - 你需要把“已广播 txHash / 已看到事件”推进到“达到 N 次确认的终局”。
>
> - 你面对的是会重组的链（EVM 常见），并且区块通知、receipt 到达可能乱序。
>
> ##### 这段逻辑的作用
>
> - pendingItem 统一模型：交易和事件都用同一套“等待→确认→回调”机制处理。
>
> - scheduleReceiptChecks：即使没新块，也会周期性强制查 receipt，防止一直卡在 pending。
>
> - dispatchReceipt + walkChainForItem：receipt 给出起点块号与块 hash，然后从后续区块逐个验证 parentHash，累计 confirmations，决定是否终局。
>
> - blockState.getByNumber 保持一致视图：在一次循环中缓存区块查询结果，保证同一高度的 block hash 不会“查前后不一致”。
>
> ##### 它在防止什么问题
>
> - 防止 乱序终局：比如后来的交易先被确认回调，早的交易反而还没确认，导致业务侧顺序错乱。
>
> - 防止 半路重组导致的错误确认：同一循环内如果链头在变化，可能把不同 fork 的区块混在一起算确认数，产生“确认数虚高/错误终局”。

- `internal/confirmations/confirmations.go`：
  - `pendingItem` 同时覆盖“事件日志”与“交易”两类对象。
  - `scheduleReceiptChecks()`：按 `staleReceiptTimeout` 重新调度 receipt 检查。
  - `dispatchReceipt()`：收到 receipt 后记录 `blockNumber/blockHash`，再 `walkChainForItem()` 去计算确认数。
  - `blockState.getByNumber()`：保证一次循环里对链的视图一致（不引入更高块、同一高度不变更 hash），防止乱序确认。

### 4.3 确认数与重组：NewFork 语义（强建议借鉴）

> 这段逻辑的意思是：确认列表不是单调递增的，遇到链重组时要允许“回退并替换”。
>
> ##### 适用场景
>
> - 链可能发生 重组 reorg（同高度出现不同 blockHash）。
>
> - 你对交易终局采用 N 次确认（或 SAFE/FINALIZED 这类需要连续确认的判定），并且需要把“确认链”持久化或下发给下游。
>
> ##### 这段逻辑的作用
>
> - 维护一个“上次已通知过的确认链（notifiedConfirmations）”。
>
> - 新一轮计算出来的 confirmations：
>
> - 如果前缀 blockHash 与已通知的不一致，说明进入了 不同 fork → newFork=true，下游必须用全量 confirmations 覆盖旧的。
>
> - 如果一致，说明仍在同一 fork 上延伸 → 下游只需增量追加新 confirmations。
>
> ##### 它在防止什么问题
>
> - 防止 重组后仍把旧 fork 的确认当成有效，导致确认数虚高、过早判定终局，或者下游保存出一条“拼接了两条不同分叉”的伪确认链。

- `dispatchConfirmations()`：
  - 维护 `notifiedConfirmations`，比较新 confirmations 的 `BlockHash` 序列：
    - 一旦发现不一致，标记 `newFork=true`，并把完整 confirmations 集合重新通知下游（替换而不是追加）。
  - 这提供了一个通用协议：下游存储 confirmations 时，若 `newFork=true` 则“全量覆盖”，否则“增量追加”。

### 4.4 confirmedBlockListener：只输出达到确认阈值的稳定区块流

> 这段逻辑的意思是：**只输出“已经足够稳定”的区块流**，把链头那段可能重组的区块先留在内存里观察，确认数够了再下发。
>
> ##### 适用场景
>
> - 你需要一个“区块事件流”给下游做处理（索引、回调、状态推进），并且希望下游**尽量不用自己处理重组**。
> - 链会发生 **reorg**，你希望以 **N 次确认后的区块**作为更可靠输入。
>
> ##### 这段逻辑的作用
>
> - 用 `requiredConfirmations` 形成一个滚动窗口：  
>   - 新块持续进入窗口尾部  
>   - **窗口头部**的块当它“落后链头 N 个块”后，才认为足够稳定并 dispatch
> - 如果检测到同高度 blockHash 冲突（reorg），就把冲突高度之后的窗口内容裁剪掉并用新分叉重新拼接；严重不一致时直接重建视图。
>
> ##### 它在防止什么问题
>
> - 防止下游收到“后来被重组掉的块”，导致重复处理、回滚补偿复杂。
> - 防止输出的区块序列出现**倒退/跳叉**（同高度不同 hash 混在一起），破坏下游对“单调递增区块流”的假设。

- `internal/confirmations/confirmed_block_listener.go`：
  - 用 `requiredConfirmations` 构建一个“滚动窗口”，只有窗口外的区块才 dispatch。
  - 对 reorg：发现同高度冲突，会裁剪并重新拼接，必要时丢弃并重建视图，保证输出的区块序列单调可靠。

### 4.5 blocklistener.BufferChannel：避免下游阻塞导致“全局停摆”

> 这段逻辑的意思是：如果某个下游处理不过来（队列满/阻塞），就宁可丢它的块通知，并标记“可能漏块”，也不让它把整个系统的块通知通道堵死。
>
> ##### 适用场景
>
> - 一个 block 通知源要同时喂给多个消费者（多个 listener/确认器/事件流）。
>
> - 个别消费者可能长时间变慢或卡住，但你希望其他消费者继续正常运行。
>
> - 系统允许用“检测到缺口后重扫/补偿”的方式来弥补漏掉的块通知。
>
> ##### 这段逻辑的作用
>
> - 隔离背压：把“慢消费者”的阻塞从全局通道中隔离出去。
>
> - 显式告警信号：用 GapPotential=true 告诉下游“你可能错过了一段块通知”，需要进入补偿逻辑（例如链上按块号重查、对账）。
>
> ##### 它在防止什么问题
>
> - 防止 单个阻塞消费者把 block 通知通道塞满，导致其它正常消费者也收不到新块（全局停摆、连锁故障、内存堆积）。

- `internal/blocklistener/blocklistener.go`：
  - 当下游确认队列满导致阻塞，会丢弃新块事件但设置 `GapPotential=true`，提示存在缺口。
  - 目的：保证“一个阻塞的 stream 不会拖死其它 stream”。

### 4.6 confirmations 的关键可调参数（建议补齐到你们系统配置）

> 这些不是“某段代码逻辑”，而是一组终局确认系统的可调参数，用来在“正确性、延迟、吞吐、对节点压力”之间做权衡。
>
> ##### 适用场景
>
> - 你要把交易从 pending 推进到终局（N 次确认或 SAFE/FINALIZED）。
>
> - 需要在高并发下持续拉 receipt、处理新区块、应对节点抖动与下游阻塞。
>
> ##### 这些参数各自的作用与防止的问题
>
> - confirmations.required：终局阈值
>
> - 作用：决定要等多少确认才算终局。
>
> - 防止：重组导致的误判终局（确认太少更容易回滚）。
>
> - confirmations.staleReceiptTimeout：receipt 兜底轮询周期
>
> - 作用：即使没新块触发，也会周期性重新查 receipt。
>
> - 防止：只靠新块触发导致的 receipt 长时间不更新/卡死（节点漏通知、监听延迟）。
>
> - confirmations.fetchReceiptUponEntry：入队立即查 receipt
>
> - 作用：交易一进入队列就尝试拿 receipt，降低“已上链但未被发现”的延迟。
>
> - 防止：等待下一次新块/超时轮询才查造成的 确认滞后（代价是更大 RPC 压力）。
>
> - confirmations.receiptWorkers：并行查 receipt 的 worker 数
>
> - 作用：提升吞吐，缩短积压。
>
> - 防止：receipt 查询成为瓶颈导致 队列堆积、确认延迟拉长（代价是更高并发请求压节点）。
>
> - confirmations.blockQueueLength / notificationQueueLength：内部缓冲队列长度
>
> - 作用：削峰填谷，把瞬时高流量变成可处理的队列。
>
> - 防止：上游瞬时爆发导致 直接阻塞或丢事件/拖死系统（太大则可能增大延迟与内存占用）。

- `confirmations.required`：确认阈值，决定何时认为终局（默认 20）。
- `confirmations.staleReceiptTimeout`：pending 交易强制重查 receipt 的周期（默认 1m），用于避免 receipt 检查“只靠新块触发”导致的滞后。
- `confirmations.fetchReceiptUponEntry`：新交易入队时是否立刻拉 receipt；否则要等新块或 stale 超时才查（默认 false）。
- `confirmations.receiptWorkers`：并行拉 receipt 的 worker 数（默认 10）。
- `confirmations.blockQueueLength / notificationQueueLength`：内部队列长度，用于削峰，避免上游阻塞把系统拖死。

---

## 5. 场景全集：nonce 正常消费与异常消费（以及 FFTM 的处理）

> 下列场景按“链上/节点状态”归类，同时给出 FFTM 的行为与可借鉴点。

### 5.1 正常路径：nonce 正常消费并终局

- 过程：
  - 分配 nonce → 写入交易记录 → submit 成功拿到 txHash → receipt 到达 → confirmations 达阈值 → 终局。
- 借鉴点：
  - 把 nonce 与交易记录绑定，状态推进由后台系统（receipt/confirmations）驱动，而不是“提交即终局”。

### 5.2 交易准备阶段被拒绝：nonce 未消费

- 触发：InvalidInputs / Reverted / InsufficientFunds 等在 prepare 阶段可判定。
- 行为：`SubmissionRejected=true`，不写库，不分配 nonce，不进入后续跟踪。
- 借鉴点：把“确定性失败”前置，避免占号与状态污染。

### 5.3 提交超时或网络错误但节点已接收：nonce 可能已被消费

- 触发：`TransactionSend` 返回错误，但实际上 tx 已进节点 txpool。
- 行为：
  - 若本地已有 txHash：`known_transaction/nonce_too_low` 视为成功（幂等）。
  - 若本地无 txHash：返回错误，并指出需要“重算 txHash”的 connector 能力来消除不确定性。
- 借鉴点：
  - 需要为“已接收但本地没记住 hash”的灰区设计补偿手段，否则会出现“误以为失败导致重复提交/nonce 冲突”。

### 5.4 长期无 receipt：nonce 未终局，可能未消费或被 txpool 丢弃

- 触发：一直查不到 receipt。
- 行为：到 `resubmitInterval` 周期触发 resubmit（同 nonce）。
- 借鉴点：
  - “未终局一段时间后失败”在 FFTM simple handler 里没有直接判死，而是倾向“重提直到成功/失败”；
  - 若你们要支持“超时判死并回收 nonce”，需要额外的业务策略与更强的链上诊断（替换检测、txpool 观察等）。

### 5.5 链重组：已看到 receipt/确认但随后回滚

- 触发：区块 hash 链断裂或 fork。
- 行为：
  - confirmations 用 `newFork` 通知下游替换确认列表；
  - confirmed block stream 会裁剪并重建后续视图，保证输出稳定块序列。
- 借鉴点：
  - 用“确认列表可回退”的协议替代“一次确认永远有效”的假设；
  - 把终局阈值配置化（requiredConfirmations）。

### 5.6 多系统共用同一 signer：nonce 可能被外部消费导致冲突

- 触发：外部系统也在用同一私钥发送交易。
- 行为：nonce 分配时取 `max(chain, db/cache)`，避免重用；但可能带来 gap 或本地 pending 与链上不一致。
- 配置建议：把 `transactions.nonceStateTimeout` 调小，让分配更频繁参考链上。
- 借鉴点：明确“单一管理源”是根本，否则只能在性能与冲突窗口之间折中。

### 5.7 进程崩溃/重启：nonce 分配过但未提交

- 触发：nonce 已写入交易记录，但未成功 submit（或 submit 前崩溃）。
- 行为（核心取决于 nonceStateTimeout）：
  - 若本地记录仍“新鲜”：倾向继续用本地 nonce + 1（保护 pending）。
  - 若已“过期”：会查询链上，并取最大值，避免重用。
- 借鉴点：`nonceStateTimeout` 是“可恢复性 vs 安全性 vs 性能”的总闸。

### 5.8 重组导致确认回退但不丢事件：确认列表可替换是必须能力

- FFTM 不把“收到若干确认”当作不可逆，而是通过 `newFork=true` 通知下游做覆盖更新。
- 这点对你们特别关键：如果你们要支持 SAFE/FINALIZED 与“长时间未终局后判定失败”，就必须允许状态从“接近终局”回退到“未终局继续等待/重提/最终失败”。

---

## 7. 本报告阅读覆盖的关键文件清单（可复查入口）

### 7.1 Nonce 与持久化

- `internal/persistence/postgres/transaction_writer.go`
- `internal/persistence/postgres/transactions.go`
- `internal/persistence/postgres/receipts.go`
- `internal/persistence/postgres/confirmations.go`
- `internal/persistence/postgres/txhistory.go`
- `internal/persistence/postgres/transaction_completions.go`
- `pkg/apitypes/managed_tx.go`

### 7.2 提交与策略循环

- `pkg/txhandler/simple/simple_transaction_handler.go`
- `pkg/txhandler/simple/policyloop.go`
- `pkg/txhandler/simple/config.go`
- `pkg/ffcapi/submission_error.go`

### 7.3 receipt、确认数、重组

- `internal/confirmations/confirmations.go`
- `internal/confirmations/receipt_checker.go`
- `internal/confirmations/confirmed_block_listener.go`
- `internal/blocklistener/blocklistener.go`
- `pkg/ffcapi/transaction_receipt.go`
- `pkg/ffcapi/next_nonce_for_signer.go`

### 7.4 配置默认值

- `internal/tmconfig/tmconfig.go`
- `config.md`

---

## 9. 本次补充的遗漏点摘要

1. **Postgres receipts/confirmations/history/completions 的落库语义**：
   - receipt/confirmations/history 很多是 **异步入 writer 队列**（性能），通过 batch 在同一 DB group 内统一落库。
   - confirmations 支持 `clearExisting`（fork）并在 batch 里先 delete 再 insert，匹配 `newFork` 语义。
   - transaction_completions 用 DB 锁保证序列可单调消费（允许回滚缺口）。
   - txhistory 支持压缩合并，避免无限膨胀。
2. **关键配置项补齐**：confirmations 的 required/staleReceiptTimeout/fetchReceiptUponEntry/receiptWorkers 等是终局系统的“性能与正确性”杠杆；transactions.nonceStateTimeout 与 simple.resubmitInterval 决定 nonce 与 pending 自愈的行为边界。













- 

